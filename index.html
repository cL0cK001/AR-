
<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ARアニメーション選択</title>
  <script src="aframe.min.js"></script>
  <script src="aframe-ar.js"></script>
  <script src="cdn.tailwindcss.com"></script>
  <script src="https://raw.githack.com/AR-js-org/AR.js/3.3.1/aframe/build/aframe-ar-nft.js"></script>
  <script src="https://cdn.jsdelivr.net/gh/donmccurdy/aframe-extras@v6.1.1/dist/aframe-extras.min.js"></script>

  <style>
    /* ARコンテナとメニューを全画面表示にするための基本スタイル */
    body, html {
      margin: 0;
      padding: 0; /* ズレ防止のため追加 */
      overflow: hidden;
      width: 100%;
      height: 100%;
      font-family: 'Inter', sans-serif;
      box-sizing: border-box;
    }
    
    /* 2つのメインコンテナにもマージン・パディングのリセットを適用 */
    #ar-container, #selection-menu {
      width: 100%;
      height: 100%;
      margin: 0;
      padding: 0;
    }

    /* AR表示関連の要素を強制的に左上に固定し、全画面にする */
    a-scene[embedded] {
      width: 100% !important;
      height: 100% !important;
      position: absolute !important;
      top: 0 !important;
      left: 0 !important;
      margin: 0 !important;
      padding: 0 !important;
      z-index: 1; /* 基準 */
    }

    .a-canvas {
      width: 100% !important;
      height: 100% !important;
      position: absolute !important;
      top: 0 !important;
      left: 0 !important;
      margin: 0 !important;
      padding: 0 !important;
      z-index: 1; /* a-scene と同じ階層に */
    }

    video {
      object-fit: cover !important;
      width: 100% !important;
      height: 100% !important;
      position: absolute !important;
      top: 0 !important;
      left: 0 !important;
      margin: 0 !important;
      padding: 0 !important;
      z-index: -1; /* 最背面に配置 */
    }

    /* 戻るボタンの z-index を ARシーンより手前に設定 */
    #btn-back {
      z-index: 10 !important; /* Tailwindのz-10より優先させる */
    }
  </style>
</head>
<body class="bg-black">
  <div id="selection-menu" class="flex flex-col items-center justify-center p-8 space-y-6 bg-gray-100">
    <h1 class="text-3xl font-bold text-gray-800 mb-4">ARアニメーションを選択</h1>
    <button id="btn-left" data-type="left" class="w-full max-w-sm p-4 bg-blue-500 text-white rounded-lg shadow-md text-lg font-semibold hover:bg-blue-600 transition duration-200">
      左に行く
    </button>
    <button id="btn-right" data-type="right" class="w-full max-w-sm p-4 bg-green-500 text-white rounded-lg shadow-md text-lg font-semibold hover:bg-green-600 transition duration-200">
      右に行く
    </button>
    <button id="btn-approach" data-type="approach" class="w-full max-w-sm p-4 bg-yellow-500 text-white rounded-lg shadow-md text-lg font-semibold hover:bg-yellow-600 transition duration-200">
      近づく
    </button>
    <button id="btn-away" data-type="away" class="w-full max-w-sm p-4 bg-red-500 text-white rounded-lg shadow-md text-lg font-semibold hover:bg-red-600 transition duration-200">
      遠ざかる
    </button>
  </div>

  <div id="ar-container" class="hidden relative">

  <a-scene embedded
             arjs="sourceType: webcam;
                   debugUIEnabled: false;
                   sourceParameters: {
                     video: {
                       width: { ideal: 1280 },
                       height: { ideal: 960 },
                       facingMode: { ideal: 'environment' }
                     }
                   }">
      <a-marker id="marker" type="pattern" url="AR-marker.patt">
      <a-entity gltf-model="#walking" animation-mixer></a-entity>
        </a-marker>

      <a-entity camera></a-entity>
    </a-scene>
    <div id="txt" style="position: fixed; bottom: 1rem; left: 1rem; z-index: 10; padding: 0.5rem; background-color: rgba(0,0,0,0.5); color: white; border-radius: 0.5rem; font-size: 0.875rem;">
      </div>

    <button id="btn-back" class="absolute bottom-6 left-1/2 -translate-x-1/2 z-10 p-3 bg-gray-800 text-white rounded-lg shadow-lg hover:bg-gray-900 transition duration-200">
      メニューに戻る
    </button>
    
  </div>

  <script>
    document.addEventListener('DOMContentLoaded', () => {
      const menu = document.getElementById('selection-menu');
      const arContainer = document.getElementById('ar-container');
      const marker = document.getElementById('marker');
      const backButton = document.getElementById('btn-back');
      const txtDisplay = document.getElementById('txt');

      let alpha = 0, beta = 0, gamma = 0;
      
      // ★ イベントが絶対モード（true）か相対モード（false）かを記録するフラグ
      let isAbsoluteMode = false;

      // -----------------------------------------------------------------
      // ★ 1. ジャイロのリスナー関数を定義
      // -----------------------------------------------------------------
      
      // ★ 絶対モード専用のリスナー
      const gyroAbsoluteListener = (dat) => {
          isAbsoluteMode = true; // 絶対モードが機能したことを記録
          alpha = dat.alpha;
          beta = dat.beta;
          gamma = dat.gamma;
          if (txtDisplay && !arContainer.classList.contains('hidden')) {
              displayData();
          }
      };
      
      // ★ 相対モード専用のリスナー (フォールバック用)
      const gyroRelativeListener = (dat) => {
          // 絶対モードがまだ機能していない場合のみ、相対モードの値を使用
          if (!isAbsoluteMode) { 
              alpha = dat.alpha;
              beta = dat.beta;
              gamma = dat.gamma;
              if (txtDisplay && !arContainer.classList.contains('hidden')) {
                  displayData();
              }
          }
      };
      
      // (選択ボタンと戻るボタンのリスナー設定は変更なし)
      const selectionButtons = document.querySelectorAll('#selection-menu button');
      selectionButtons.forEach(button => {
        button.addEventListener('click', () => {
          const animationType = button.getAttribute('data-type');
          startAR(animationType);
        });
      });
      backButton.addEventListener('click', () => {
        showMenu();
      });


      /**
       * ARシーンを開始する関数
       */
      async function startAR(type) {

        // ★ リセット
        isAbsoluteMode = false; 

        // -----------------------------------------------------------------
        // ★ 2. センサー許可リクエスト
        // -----------------------------------------------------------------
        if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
          try {
            const permissionState = await DeviceOrientationEvent.requestPermission(); 
            
            if (permissionState === 'granted') {
              // ★ 3. 【重要】両方のイベントリスナーを登録する
              // (絶対モードが利用可能なら gyroAbsoluteListener が呼ばれる)
              window.addEventListener("deviceorientationabsolute", gyroAbsoluteListener, true);
              // (絶対モードがダメな場合のフォールバックとして、相対モードも登録)
              window.addEventListener("deviceorientation", gyroRelativeListener, true);
              
              if (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function') {
                await DeviceMotionEvent.requestPermission();
              }
            } else {
              alert('「向きセンサー」の利用が許可されませんでした。');
            }
          } catch (error) {
            console.error('センサーの許可リクエスト中にエラー:', error);
          }
        }
        // -----------------------------------------------------------------

        // (モデルの作成とアニメーション設定は変更なし)
        const existingModel = document.getElementById('current-model');
        if (existingModel) {
          marker.removeChild(existingModel);
        }
        const model = document.createElement('a-entity');
        model.setAttribute('id', 'current-model');
        model.setAttribute('gltf-model', 'birditi.glb'); 
        model.setAttribute('animation-mixer', {}); 
        switch (type) {
          case 'left':
            model.setAttribute('rotation', '90 -90 180');
            model.setAttribute('scale', '3 3 3');
            model.setAttribute('animation', {
                property: 'position', from: '0 0 0', to: '-5 0 0', 
                dur: 4000, dir: 'normal', loop: true
            });
            break;
          case 'right':
            model.setAttribute('rotation', '90 90 180');
            model.setAttribute('scale', '3 3 3');
            model.setAttribute('animation', {
              property: 'position', from: '0 0 0', to: '5 0 0', 
              dur: 4000, dir: 'normal', loop: true
            });
            break;
          case 'approach':
            model.setAttribute('rotation', '-90 0 0');
            model.setAttribute('scale', '1 1 1'); 
            model.setAttribute('animation', {
              property: 'scale', from: '1 1 1', to: '10 10 10',
              dur: 15000, loop: false
            });
            break;
          case 'away':
            model.setAttribute('rotation', '90 0 180');
            model.setAttribute('scale', '10 10 10'); 
            model.setAttribute('animation', {
              property: 'scale', from: '10 10 10', to: '1 1 1',
              dur: 20000, loop: false
            });
            break;
        }
        marker.appendChild(model);
        menu.classList.add('hidden');
        arContainer.classList.remove('hidden');
        setTimeout(() => window.dispatchEvent(new Event('resize')), 100);
      }

      /**
       * メニュー画面に戻る関数
       */
      function showMenu() {
        arContainer.classList.add('hidden');
        menu.classList.remove('hidden');

        const existingModel = document.getElementById('current-model');
        if (existingModel) {
          marker.removeChild(existingModel);
        }
        
        // ★ 4. 両方のリスナーを削除
        window.removeEventListener("deviceorientationabsolute", gyroAbsoluteListener, true);
        window.removeEventListener("deviceorientation", gyroRelativeListener, true);
        
        if (txtDisplay) {
          txtDisplay.innerHTML = "";
        }
      }

      /**
       * センサーデータを画面に表示する関数
       */
      function displayData() {
        if(txtDisplay) {
          // ★ 絶対モード(true)か相対モード(false)かを表示
          const mode = isAbsoluteMode ? "絶対 (北=0°)" : "相対 (起動時=0°)";
          
          txtDisplay.innerHTML = "<b>モード: " + mode + "</b><br>"
                               + "alpha (Z軸/方位): " + Math.round(alpha) + "°<br>"
                               + "beta (X軸/前後):  " + Math.round(beta) + "°<br>"
                               + "gamma (Y軸/左右): " + Math.round(gamma) + "°";
        }
      }
    });
  </script>
</body>
</html>